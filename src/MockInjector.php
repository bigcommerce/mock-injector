<?php
namespace Bigcommerce\MockInjector;

use Bigcommerce\Injector\InjectorFactory;
use Bigcommerce\Injector\InjectorInterface;
use Prophecy\Exception\Prediction\AggregateException;
use Prophecy\Prophecy\ObjectProphecy;
use Prophecy\Prophet;

/**
 * The MockInjector is a specialised version of the injector that automatically mocks dependencies of objects being
 * tested using the same introspection of parameter types as the default Injector.
 * Note that any prophecy mock auto-generated by the MockInjector can be accessed via the ::getMock method.
 * @package \Bigcommerce\Injector
 */
class MockInjector implements InjectorInterface
{
    /**
     * @var InjectorInterface
     */
    private $injector;
    /**
     * @var MockingContainerInterface
     */
    private $mockingContainer;

    /**
     * MockInjector constructor.
     * NOTE: The MockInjector intentionally does not use DependencyInjection and instantiates its own
     * dependencies via poor mans DI as it is used only for testing purposes and is tightly coupled to
     * its dependencies.
     * @param MockingContainerInterface $mockingContainer
     * @param InjectorInterface $injector
     */
    public function __construct(
        ?MockingContainerInterface $mockingContainer = null,
        ?InjectorInterface $injector = null
    ) {
        $this->mockingContainer = $mockingContainer ?? new ProphecyMockingContainer(new Prophet());
        if (!$injector) {
            $injector = InjectorFactory::create($this->mockingContainer, serviceCache: new StaticArrayServiceCache());
        }
        $this->injector = $injector;
    }

    /**
     * Checks all predictions defined by prophecies of this Prophet.
     *
     * @throws AggregateException If any prediction fails
     */
    public function checkPredictions()
    {
        $this->mockingContainer->checkPredictions();
    }


    /**
     * @param string $mockClassName FQCN of the dependency we mocked
     * @return ObjectProphecy
     * @deprecated
     * @see MockInjector::getProphecy()
     */
    public function getMock($mockClassName)
    {
        return $this->getProphecy($mockClassName);
    }

    /**
     * Fetch one of the mocks that was auto-created by the MockContainer to construct objects used in the current test,
     * so that you can set expectations or configure mock methods.
     * @param string $mockClassName FQCN of the dependency we mocked
     * @return ObjectProphecy
     */
    public function getProphecy($mockClassName)
    {
        return $this->mockingContainer->getMock($mockClassName);
    }

    /**
     * Fetch all of the mocks that was auto-created by the MockContainer to construct objects used in the current test,
     * so that you can set expectations or configure mock methods.
     * @return ObjectProphecy[]
     */
    public function getAllMocks()
    {
        return $this->mockingContainer->getAllMocks();
    }


    /**
     * Instantiate an object and attempt to inject the dependencies for the class by mapping constructor parameter \
     * names to mock objects
     *
     * The optional $parameters passed to this method accept and will inject values based on:
     *  - Type:  [Cache::class => new RedisCache()] will inject RedisCache to each parameter typed Cache::class
     *  - Name:  ["cache" => new RedisCache()] will inject RedisCache to the parameter named $cache
     *  - Index: [ 3 => new RedisCache()] will inject RedisCache to the 4th parameter (zero index)
     *
     * @param string $className The fully qualified class name for the object we're creating
     * @param array $parameters An optional array of additional parameters to pass to the created objects constructor.
     * @throws \Exception
     * @return object
     */
    public function create($className, $parameters = [])
    {
        return $this->injector->create($className, $parameters);
    }

    /**
     * Call a method with parameter dependency injection from mock objects. This is functionally equivalent to
     * call_user_func_array with auto-wiring against mocks.
     *
     * The optional $parameters passed to this method accept and will inject values based on:
     *  - Type:  [Cache::class => new RedisCache()] will inject RedisCache to each parameter typed Cache::class
     *  - Name:  ["cache" => new RedisCache()] will inject RedisCache to the parameter named $cache
     *  - Index: [ 3 => new RedisCache()] will inject RedisCache to the 4th parameter (zero index)
     *
     * @param object $instance
     * @param string $methodName
     * @param array $parameters
     * @return mixed
     * @throws \Exception
     */
    public function invoke($instance, $methodName, $parameters = [])
    {
        return $this->injector->invoke($instance, $methodName, $parameters);
    }
}
